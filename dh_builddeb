#!/usr/bin/perl

=head1 NAME

dh_builddeb - build Debian binary packages

=cut

use strict;
use warnings;
use Debian::Debhelper::Dh_Lib;

=head1 SYNOPSIS

B<dh_builddeb> [S<I<debhelper options>>] [B<--destdir=>I<directory>] [B<--filename=>I<name>] [S<B<--> I<params>>]

=head1 DESCRIPTION

B<dh_builddeb> simply calls L<dpkg-deb(1)> to build a Debian package or
packages.  It will also build packages for ddebs when L<dh_strip(1)>
and L<dh_gencontrol(1)> have prepared them.

It supports building multiple binary packages in parallel, when enabled by
DEB_BUILD_OPTIONS.

=head1 OPTIONS

=over 4

=item B<--destdir=>I<directory>

Use this if you want the generated F<.deb> files to be put in a directory
other than the default of "F<..>".

=item B<--filename=>I<name>

Use this if you want to force the generated .deb file to have a particular
file name. Does not work well if more than one .deb is generated!

=item B<--> I<params>

Pass I<params> to L<dpkg-deb(1)> when it is used to build the
package.

=item B<-u>I<params>

This is another way to pass I<params> to L<dpkg-deb(1)>.
It is deprecated; use B<--> instead.

=back

=cut

init(options => {
	"filename=s" => \$dh{FILENAME},
	"destdir=s" => \$dh{DESTDIR},
});

# Set the default destination directory.
if (! defined $dh{DESTDIR}) {
	$dh{DESTDIR}='..';
}

if (! defined $dh{FILENAME}) {
	$dh{FILENAME}='';
}
else {
	$dh{FILENAME}="/$dh{FILENAME}";
}

my $max_procs=get_buildoption("parallel") || 1;

my $processes=1;
my $exit=0;
sub reap {
	if (wait == -1) {
		$processes=0;
	}
	else {
		$processes--;
		$exit=1 if $? != 0;
	}
}

sub default_compressor_args {
	my ($default_comp, @args) = @_;

	for my $arg (@args) {
		# Explicit compressor arg given
		return @args if $arg =~ m/^-Z/;
	}

	return (@{$default_comp}, @args);
}

foreach my $package (@{$dh{DOPACKAGES}}) {
	my $pid=fork();
	if (! defined $pid) {
		error("fork failed! $!");
	}
	if ($pid) { # parent
		$processes++;
		reap while $processes > $max_procs;
		next;
	}

	# child
	my $tmp=tmpdir($package);
	my $ddeb_tmpdir = "debian/.debhelper/${package}/ddeb-root";
	if (exists $ENV{DH_ALWAYS_EXCLUDE} && length $ENV{DH_ALWAYS_EXCLUDE}) {
		if (! compat(5)) {
			complex_doit("find $tmp $dh{EXCLUDE_FIND} | xargs rm -rf");
		}
		else {
			# Old broken code here for compatibility. Does not
			# remove everything.
			complex_doit("find $tmp -name $_ | xargs rm -rf")
				foreach split(":", $ENV{DH_ALWAYS_EXCLUDE});
		}
	}
	if ( -d $ddeb_tmpdir) {
		my $ddeb_control = "${ddeb_tmpdir}/DEBIAN/control";
		# Only build the ddeb if it has a control file.  People might
		# have skipped dh_gencontrol.
		if ( -f $ddeb_control ) {
			# XXX: Should we blindly overrule the maintainer here?  It
			# is not apparent that their explicit -z was intended for
			# the ddeb.
			my @args = default_compressor_args(["-z1", "-Zxz", "-Sextreme"],
											   @{$dh{U_PARAMS}});
			doit("dpkg-deb", @args,
				 "--build", $ddeb_tmpdir, $dh{DESTDIR});
		} else {
			warning("Not building ddeb for ${package} as it has no control file");
			warning("Please use dh_gencontrol to avoid this issue");
		}
	}
	if (! is_udeb($package)) {
		doit("dpkg-deb", @{$dh{U_PARAMS}}, "--build", $tmp, $dh{DESTDIR}.$dh{FILENAME});
	}
	else {
		my $filename=$dh{FILENAME};
		if (! $filename) {
			$filename="/".udeb_filename($package);
		}
		doit("dpkg-deb", "-z1", "-Zxz", "-Sextreme",
			@{$dh{U_PARAMS}}, "--build", $tmp, $dh{DESTDIR}.$filename);
	}
	exit 0;
}

reap while $processes;
exit $exit;

=head1 SEE ALSO

L<debhelper(7)>

This program is a part of debhelper.

=head1 AUTHOR

Joey Hess <joeyh@debian.org>

=cut

# Local Variables:
# indent-tabs-mode: t
# tab-width: 4
# cperl-indent-level: 4
# End:
